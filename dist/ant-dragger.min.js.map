{"version":3,"file":"ant-dragger.min.js","sources":["../node_modules/react-dnd/lib/utils/shallowEqual.js","../src/Draggable.js","../src/EventType.js","../src/EventDispatcher.js","../src/Dragger.js","../src/EventCreator.js","../src/DraggerContext.js","../src/DraggerHandler.js","../src/index.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.default = shallowEqual;\nfunction shallowEqual(objA, objB) {\n\tif (objA === objB) {\n\t\treturn true;\n\t}\n\n\tvar keysA = Object.keys(objA);\n\tvar keysB = Object.keys(objB);\n\n\tif (keysA.length !== keysB.length) {\n\t\treturn false;\n\t}\n\n\t// Test for A's keys different from B.\n\tvar hasOwn = Object.prototype.hasOwnProperty;\n\tfor (var i = 0; i < keysA.length; i += 1) {\n\t\tif (!hasOwn.call(objB, keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar valA = objA[keysA[i]];\n\t\tvar valB = objB[keysA[i]];\n\n\t\tif (valA !== valB) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}","import React from 'react'\nimport PropTypes from 'prop-types'\nimport {\n  DragSource,\n  DropTarget\n} from 'react-dnd'\nimport shallowEqual from 'react-dnd/lib/utils/shallowEqual'\nimport {\n  BEGIN_DRAG,\n  END_DRAG,\n  HOVER,\n  ENTER,\n  LEAVE,\n  DROP,\n\n  CAN_DRAG,\n  CAN_DROP\n} from './EventType'\n\nclass Draggable extends React.Component {\n  static childContextTypes = {\n    dragSourceCreator: PropTypes.func,\n    dragCursor: PropTypes.string,\n    dragHandlerType: PropTypes.string\n  }\n\n  getChildContext () {\n    return {\n      dragSourceCreator: this.props.connectDragSource,\n      dragCursor: this.props.dragCursor,\n      dragHandlerType: this.props.dragHandlerType\n    }\n  }\n\n  componentDidMount () {\n    const {\n      children,\n\n      dragToken,\n      draggerPreview,\n      connectDragPreview\n    } = this.props\n\n    if (draggerPreview && typeof draggerPreview === 'function') {\n      const node = draggerPreview(dragToken(), children.props)\n      if (typeof node === 'function') {\n        node(connectDragPreview)\n      } else if (typeof node.then === 'function') {\n        node.then(connectDragPreview)\n      } else {\n        connectDragPreview(node)\n      }\n    }\n  }\n\n  componentDidUpdate (prevProps, prevState) {\n    const {\n      dragToken,\n      dispatcher,\n      isOver: currIsOver,\n      item\n    } = this.props\n    const {\n      isOver: prevIsOver\n    } = prevProps\n\n    if (!prevIsOver && currIsOver) { // enter\n      dispatcher(ENTER, {\n        source: item && item.$source,\n        target: dragToken(),\n        props: this.props,\n        component: this\n      })\n    } else if (!currIsOver && prevIsOver) { // leave\n      dispatcher(LEAVE, {\n        source: item && item.$source,\n        target: dragToken(),\n        props: this.props,\n        component: this\n      })\n    }\n  }\n\n  render () {\n    const {\n      children,\n\n      dispatcher,\n      dragToken,\n      dragCursor,\n      draggingHint,\n      dragHandlerType,\n      wrapTag: Tag,\n      wrapStyle,\n      wrapClassName,\n      draggerPreview,\n\n      connectDragSource,\n      connectDropTarget,\n      connectDragPreview,\n      isDragging,\n      isOver,\n      item,\n      itemType,\n      differenceFromInitialOffset,\n      initialClientOffset,\n      initialSourceClientOffset,\n      clientOffset,\n      sourceClientOffset,\n\n      ...otherProps\n    } = this.props\n\n    let className = wrapClassName\n    if (typeof className !== 'string' &&\n        typeof className.join === 'function') {\n      className = className.join(' ')\n    }\n\n    const style = {\n      cursor: dragHandlerType !== 'default' ? 'auto' : dragCursor,\n      ...wrapStyle\n    }\n\n    let props = {\n      className,\n      style,\n      ...otherProps\n    }\n\n    let child = children\n    if (typeof child !== 'string') {\n      child = React.Children.only(child)\n    }\n\n    if ((isDragging &&\n        typeof draggingHint === 'function' &&\n        differenceFromInitialOffset !== null)) {\n      const newProps = draggingHint(props, child)\n      if (newProps) {\n        props = newProps\n      }\n    }\n\n    if (typeof child.type !== 'string') {\n      child = (\n        <Tag {...props}>{child}</Tag>\n      )\n    } else {\n      child = React.cloneElement(child, {\n        ...child.props,\n        ...props,\n        style: {\n          ...child.props.style,\n          ...props.style\n        }\n      })\n    }\n\n    if (!draggerPreview) {\n      child = connectDragPreview(child)\n    }\n    if (dragHandlerType === 'default') {\n      child = connectDragSource(child)\n    }\n    return connectDropTarget(child)\n  }\n}\n\nclass DraggableWrapper extends React.Component {\n  static contextTypes = {\n    dispatcher: PropTypes.func,\n    draggerType: PropTypes.string,\n    dragDropManager: PropTypes.object,\n    draggerPreview: PropTypes.func\n  }\n\n  static propTypes = {\n    dragToken: PropTypes.func.isRequired,\n    draggingHint: PropTypes.func,\n    dragHandlerType: PropTypes.oneOf(['default', 'handler']),\n    dragCursor: PropTypes.oneOf(['default', 'move', 'pointer']),\n    wrapTag: PropTypes.string,\n    wrapStyle: PropTypes.object,\n    wrapClassName: PropTypes.oneOfType([\n      PropTypes.arrayOf(PropTypes.string),\n      PropTypes.string\n    ])\n  }\n\n  static defaultProps = {\n    wrapTag: 'div',\n    dragCursor: 'default',\n    dragHandlerType: 'default',\n    wrapStyle: {},\n    wrapClassName: ''\n  }\n\n  dragSource = {\n    beginDrag: this.dispatchBeginDragEvent.bind(this),\n    endDrag: this.dispatchEndDragEvent.bind(this),\n    canDrag: this.dispatchCanDragEvent.bind(this)\n  }\n\n  dropTarget = {\n    hover: this.dispatchHoverEvent.bind(this),\n    drop: this.dispatchDropEvent.bind(this),\n    canDrop: this.dispatchCanDropEvent.bind(this)\n  }\n\n  constructor (props, context) {\n    super(props, context)\n    this.cachedWrapped = undefined\n  }\n\n  componentWillUnmount () {\n    this.cachedWrapped = undefined\n  }\n\n  dispatchBeginDragEvent (props, monitor, component) {\n    const source = this.props.dragToken()\n    let result = this.context.dispatcher(\n      BEGIN_DRAG,\n      {\n        source,\n        props,\n        component\n      }\n    )\n    if (result === undefined) {\n      result = {}\n    }\n    if (result.dragToken === undefined) {\n      result.dragToken = source\n    }\n    result.$target = result.$source = result.dragToken\n    return result\n  }\n\n  dispatchEndDragEvent (props, monitor, component) {\n    const {\n      $target: target,\n      $source: source\n    } = monitor.getItem()\n    this.context.dispatcher(\n      END_DRAG,\n      {\n        target,\n        source,\n        props,\n        component\n      }\n    )\n  }\n\n  dispatchCanDragEvent (props, monitor) {\n    const source = this.props.dragToken()\n    let result = this.context.dispatcher(\n      CAN_DRAG,\n      {\n        source,\n        props\n      }\n    )\n    if (result === undefined) {\n      result = true\n    }\n    return result\n  }\n\n  dispatchHoverEvent (props, monitor, component) {\n    const current = component.props.dragToken()\n    const source = monitor.getItem().$source\n\n    if (shallowEqual(current, source) && current === source) {\n      return\n    }\n\n    monitor.getItem().$target = current\n    const handled = this.context.dispatcher(\n      HOVER,\n      {\n        target: current,\n        source,\n        props,\n        component\n      }\n    )\n\n    if (handled && (handled.constructor === current.constructor)) {\n      monitor.getItem().$target = handled\n    }\n    return handled\n  }\n\n  dispatchDropEvent (props, monitor, component) {\n    const {\n      $target: target,\n      $source: source\n    } = monitor.getItem()\n    const handled = this.context.dispatcher(\n      DROP,\n      {\n        target,\n        source,\n        props,\n        component\n      }\n    )\n    return handled\n  }\n\n  dispatchCanDropEvent (props, monitor) {\n    const {\n      $target: target,\n      $source: source\n    } = monitor.getItem()\n    let result = this.context.dispatcher(\n      CAN_DROP,\n      {\n        target,\n        source,\n        props\n      }\n    )\n    if (result === undefined) {\n      result = true\n    }\n    return result\n  }\n\n  render () {\n    const {\n      children,\n      dragToken,\n      dragCursor,\n      draggingHint,\n      wrapTag,\n      wrapStyle,\n      wrapClassName,\n      ...otherProps\n    } = this.props\n\n    const {\n      dispatcher,\n      draggerType,\n      draggerPreview\n    } = this.context\n\n    if (!this.cachedWrapped) {\n      this.cachedWrapped = DragSource(draggerType, this.dragSource, (connect, monitor) => ({\n        connectDragSource: connect.dragSource(),\n        connectDragPreview: connect.dragPreview(),\n        isDragging: monitor.isDragging(),\n        initialClientOffset: monitor.getInitialClientOffset(),\n        initialSourceClientOffset: monitor.getInitialSourceClientOffset()\n      }))(\n        DropTarget(draggerType, this.dropTarget, (connect, monitor) => ({\n          connectDropTarget: connect.dropTarget(),\n          isOver: monitor.isOver({ shallow: true }),\n          item: monitor.getItem(),\n          itemType: monitor.getItemType(),\n          differenceFromInitialOffset: monitor.getDifferenceFromInitialOffset(),\n          clientOffset: monitor.getClientOffset(),\n          sourceClientOffset: monitor.getSourceClientOffset()\n        }))(Draggable)\n      )\n    }\n    const Wrapped = this.cachedWrapped\n\n    const wrappedProps = {\n      dragCursor,\n      draggingHint,\n      wrapTag,\n      wrapStyle,\n      wrapClassName,\n      draggerPreview,\n      dragToken,\n      dispatcher\n    }\n\n    return (\n      <Wrapped {...wrappedProps} {...otherProps}>{children}</Wrapped>\n    )\n  }\n}\n\nexport default DraggableWrapper\n","export const BEGIN_DRAG = 'BEGIN_DRAG'\nexport const END_DRAG = 'END_DRAG'\nexport const DROP = 'DROP'\nexport const HOVER = 'HOVER'\nexport const ENTER = 'ENTER'\nexport const LEAVE = 'LEAVE'\nexport const CAN_DRAG = 'CAN_DRAG'\nexport const CAN_DROP = 'CAN_DROP'\n","export default (fn) => (type, event) => fn(type, event)\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport PropTypes from 'prop-types'\nimport eventDispatcher from './EventDispatcher'\nimport eventCreator from './EventCreator'\n\nimport {\n  DropTarget\n} from 'react-dnd'\n\nimport {\n  BEGIN_DRAG,\n  END_DRAG,\n  HOVER,\n  ENTER,\n  LEAVE,\n  DROP,\n  CAN_DRAG,\n  CAN_DROP\n} from './EventType'\n\nconst EVENT_FUNC = {\n  [BEGIN_DRAG]: 'onDragStart',\n  [END_DRAG]: 'onDragEnd',\n  [HOVER]: 'onDragging',\n  [ENTER]: 'onDragEnter',\n  [LEAVE]: 'onDragLeave',\n  [DROP]: 'onDrop',\n  [CAN_DRAG]: 'canDrag',\n  [CAN_DROP]: 'canDrop'\n}\n\nconst noop = () => {}\n\nclass Dragger extends React.Component {\n  static propTypes = {\n    onDragStart: PropTypes.func,\n    onDragEnd: PropTypes.func,\n    onDrop: PropTypes.func,\n    onDragging: PropTypes.func,\n    onDragEnter: PropTypes.func,\n    onDragLeave: PropTypes.func,\n    canDrag: PropTypes.func,\n    canDrop: PropTypes.func,\n    draggerType: PropTypes.string,\n    draggerPreview: PropTypes.func\n  }\n\n  static defaultProps = {\n    onDragStart: noop,\n    onDragEnd: noop,\n    onDrop: noop,\n    onDragging: noop,\n    onDragEnter: noop,\n    onDragLeave: noop,\n    canDrag: () => true,\n    canDrop: undefined,\n    draggerType: '__dragger__',\n    draggerPreview: undefined\n  }\n\n  static childContextTypes = {\n    dispatcher: PropTypes.func,\n    draggerType: PropTypes.string,\n    draggerPreview: PropTypes.func\n  }\n\n  static contextTypes = {\n    dragDropManager: PropTypes.object\n  }\n\n  constructor (props, context) {\n    super(props, context)\n    this.notifyHandler = this.notifyHandler.bind(this)\n    this.dispatcher = eventDispatcher(this.notifyHandler)\n  }\n\n  getChildContext () {\n    return {\n      dispatcher: this.dispatcher,\n      draggerType: this.props.draggerType,\n      draggerPreview: this.props.draggerPreview\n    }\n  }\n\n  notifyHandler (type, { target, source, props, component }) {\n    let fn = this.props[EVENT_FUNC[type]]\n    if (type === CAN_DROP && !fn) {\n      fn = this.props.canDrag\n    }\n    if (!fn) {\n      console.warn('Unknown event type', type)\n    }\n    return fn && fn(eventCreator(source, target)(props), props, component)\n  }\n\n  render () {\n    const {\n      connectDropTarget\n    } = this.props\n\n    return connectDropTarget(React.Children.only(this.props.children))\n  }\n}\n\nclass Wrapper extends React.Component {\n  static propTypes = {\n    onDragEdge: PropTypes.func,\n    edgeWidth: PropTypes.oneOfType([\n      PropTypes.number,\n      PropTypes.object\n    ]),\n    draggerType: PropTypes.string\n  }\n\n  static defaultProps = {\n    onDragEdge: noop,\n    edgeWidth: 20,\n    draggerType: '__dragger__'\n  }\n\n  dropTarget = {\n    hover: this.handleContainerHover.bind(this)\n  }\n\n  constructor (props) {\n    super(props)\n    this.edgeWidth = this.props.edgeWidth\n    if (typeof this.edgeWidth === 'number') {\n      const v = this.edgeWidth\n      this.edgeWidth = {\n        left: v,\n        top: v,\n        right: v,\n        bottom: v\n      }\n    }\n    this.cachedWrapped = undefined\n  }\n\n  componentWillUnmount () {\n    this.cachedWrapped = undefined\n  }\n\n  componentDidMount () {\n    this.refreshBoundingRect()\n  }\n\n  componentDidUpdate () {\n    this.refreshBoundingRect()\n  }\n\n  handleContainerHover (props, monitor, component) {\n    const {\n      x: clientX,\n      y: clientY\n    } = monitor.getClientOffset()\n    const {\n      left, top, right, bottom\n    } = this.containerBoundingRect\n    const {\n      left: edgeLeft,\n      top: edgeTop,\n      right: edgeRight,\n      bottom: edgeBottom\n    } = this.edgeWidth\n    const containerEdge = {\n      left: left + edgeLeft,\n      top: top + edgeTop,\n      right: right - edgeRight,\n      bottom: bottom - edgeBottom\n    }\n    const strike = {\n      left: clientX <= containerEdge.left,\n      top: clientY <= containerEdge.top,\n      right: clientX >= containerEdge.right,\n      bottom: clientY >= containerEdge.bottom\n    }\n\n    if (strike.left || strike.top || strike.right || strike.bottom) {\n      this.props.onDragEdge({\n        strike,\n        client: {\n          x: clientX,\n          y: clientY\n        },\n        edge: containerEdge,\n        itemType: monitor.getItemType(),\n        initialClientOffset: monitor.getInitialClientOffset(),\n        initialSourceClientOffset: monitor.getInitialSourceClientOffset(),\n        clientOffset: monitor.getClientOffset(),\n        sourceClientOffset: monitor.getSourceClientOffset(),\n        differenceFromInitialOffset: monitor.getDifferenceFromInitialOffset()\n      }, props, component)\n    }\n  }\n\n  refreshBoundingRect () {\n    setTimeout(() => {\n      const el = ReactDOM.findDOMNode(this)\n      this.containerBoundingRect = el.getBoundingClientRect()\n    }, 0)\n  }\n\n  render () {\n    if (!this.cachedWrapped) {\n      this.cachedWrapped = DropTarget(\n        this.props.draggerType,\n        this.dropTarget,\n        (collect, monitor) => ({\n          connectDropTarget: collect.dropTarget()\n        })\n      )(Dragger)\n    }\n    const Wrap = this.cachedWrapped\n\n    return (\n      <Wrap {...this.props}>{this.props.children}</Wrap>\n    )\n  }\n}\n\nexport default Wrapper\n","export default (source, target) => (options = {}) => {\n  const base = {\n    source,\n    target\n  }\n  const extra = {\n    item: options.item,\n    itemType: options.itemType,\n    isDragging: options.isDragging,\n    isOver: options.isOver,\n\n    differenceFromInitialOffset: options.differenceFromInitialOffset,\n    initialClientOffset: options.initialClientOffset,\n    initialSourceClientOffset: options.initialSourceClientOffset,\n    clientOffset: options.clientOffset,\n    sourceClientOffset: options.sourceClientOffset\n  }\n\n  return {\n    ...base,\n    ...extra\n  }\n}\n","import {\n  DragDropContext\n} from 'react-dnd'\nimport HTML5Backend from 'react-dnd-html5-backend'\n\nexport default DragDropContext(HTML5Backend)\n","import React from 'react'\nimport PropTypes from 'prop-types'\n\nclass DraggerHandler extends React.Component {\n  static contextTypes = {\n    dragSourceCreator: PropTypes.func,\n    dragHandlerType: PropTypes.string,\n    dragCursor: PropTypes.string\n  }\n\n  static propTypes = {\n    wrapTag: PropTypes.string\n  }\n\n  static defaultProps = {\n    wrapTag: 'div'\n  }\n\n  render () {\n    const {\n      dragSourceCreator,\n      dragHandlerType,\n      dragCursor\n    } = this.context\n\n    const style = {\n      cursor: dragCursor,\n      ...this.props.style\n    }\n    const className = this.props.className\n\n    let children = this.props.children\n    if (dragHandlerType === 'handler') {\n      const Tag = this.props.wrapTag\n      children = dragSourceCreator(\n        <Tag className={className} style={style}>{children}</Tag>\n      )\n    }\n    return children\n  }\n}\n\nexport default DraggerHandler\n","import _Draggable from './Draggable'\nimport _Dragger from './Dragger'\nimport _DraggerContext from './DraggerContext'\nimport _DraggerHandler from './DraggerHandler'\n\nexport const Draggable = _Draggable\nexport const Dragger = _Dragger\nexport const DraggerContext = _DraggerContext\nexport const DraggerHandler = _DraggerHandler\n\nexport default {\n  Draggable,\n  Dragger,\n  DraggerContext,\n  DraggerHandler\n}\n"],"names":["Object","defineProperty","exports","value","objA","objB","keysA","keys","keysB","length","hasOwn","prototype","hasOwnProperty","i","call","valA","valB","Draggable","this","props","connectDragSource","dragCursor","dragHandlerType","children","dragToken","draggerPreview","connectDragPreview","node","then","prevProps","prevState","dispatcher","currIsOver","isOver","item","prevIsOver","$source","draggingHint","Tag","wrapTag","wrapStyle","wrapClassName","connectDropTarget","isDragging","differenceFromInitialOffset","itemType","otherProps","initialClientOffset","initialSourceClientOffset","clientOffset","sourceClientOffset","className","join","style","child","React","Children","only","newProps","type","cloneElement","Component","childContextTypes","PropTypes","func","string","DraggableWrapper","context","dragSource","_this2","dispatchBeginDragEvent","bind","dispatchEndDragEvent","dispatchCanDragEvent","dropTarget","dispatchHoverEvent","dispatchDropEvent","dispatchCanDropEvent","cachedWrapped","undefined","monitor","component","source","result","$target","getItem","target","current","shallowEqual","handled","constructor","draggerType","DragSource","connect","dragPreview","getInitialClientOffset","getInitialSourceClientOffset","DropTarget","shallow","getItemType","getDifferenceFromInitialOffset","getClientOffset","getSourceClientOffset","Wrapped","wrappedProps","contextTypes","object","propTypes","isRequired","oneOf","oneOfType","arrayOf","defaultProps","fn","event","EVENT_FUNC","noop","Dragger","notifyHandler","_this","eventDispatcher","canDrag","warn","options","base","extra","eventCreator","Wrapper","handleContainerHover","edgeWidth","v","refreshBoundingRect","clientX","x","clientY","y","containerBoundingRect","left","top","right","bottom","containerEdge","strike","onDragEdge","el","ReactDOM","findDOMNode","getBoundingClientRect","collect","Wrap","number","DragDropContext","HTML5Backend","dragSourceCreator","DraggerHandler","_Draggable","_Dragger","DraggerContext","_DraggerContext","_DraggerHandler"],"mappings":"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"}