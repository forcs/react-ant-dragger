{"version":3,"file":"ant-dragger.min.js","sources":["../node_modules/react-dnd/lib/utils/shallowEqual.js","../src/EventType.js","../src/Draggable.js","../src/EventDispatcher.js","../src/EventCreator.js","../src/Dragger.js","../src/DraggerContext.js","../src/DraggerHandler.js","../src/index.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.default = shallowEqual;\nfunction shallowEqual(objA, objB) {\n\tif (objA === objB) {\n\t\treturn true;\n\t}\n\n\tvar keysA = Object.keys(objA);\n\tvar keysB = Object.keys(objB);\n\n\tif (keysA.length !== keysB.length) {\n\t\treturn false;\n\t}\n\n\t// Test for A's keys different from B.\n\tvar hasOwn = Object.prototype.hasOwnProperty;\n\tfor (var i = 0; i < keysA.length; i += 1) {\n\t\tif (!hasOwn.call(objB, keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar valA = objA[keysA[i]];\n\t\tvar valB = objB[keysA[i]];\n\n\t\tif (valA !== valB) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}","export const BEGIN_DRAG = 'BEGIN_DRAG'\nexport const END_DRAG = 'END_DRAG'\nexport const DROP = 'DROP'\nexport const HOVER = 'HOVER'\nexport const ENTER = 'ENTER'\nexport const LEAVE = 'LEAVE'\nexport const CAN_DRAG = 'CAN_DRAG'\nexport const CAN_DROP = 'CAN_DROP'\n","import React from 'react'\nimport PropTypes from 'prop-types'\nimport {\n  DragSource,\n  DropTarget\n} from 'react-dnd'\nimport shallowEqual from 'react-dnd/lib/utils/shallowEqual'\nimport {\n  BEGIN_DRAG,\n  END_DRAG,\n  HOVER,\n  ENTER,\n  LEAVE,\n  DROP,\n\n  CAN_DRAG,\n  CAN_DROP\n} from './EventType'\n\nclass Draggable extends React.Component {\n  static childContextTypes = {\n    dragSourceCreator: PropTypes.func,\n    dragCursor: PropTypes.string,\n    dragHandlerType: PropTypes.string\n  }\n\n  getChildContext () {\n    return {\n      dragSourceCreator: this.props.connectDragSource,\n      dragCursor: this.props.dragCursor,\n      dragHandlerType: this.props.dragHandlerType\n    }\n  }\n\n  componentDidMount () {\n    const {\n      children,\n\n      dragToken,\n      draggerPreview,\n      connectDragPreview\n    } = this.props\n\n    if (draggerPreview && typeof draggerPreview === 'function') {\n      const node = draggerPreview(dragToken(), children.props)\n      if (typeof node === 'function') {\n        node(connectDragPreview)\n      } else if (typeof node.then === 'function') {\n        node.then(connectDragPreview)\n      } else {\n        connectDragPreview(node)\n      }\n    }\n  }\n\n  componentDidUpdate (prevProps, prevState) {\n    const {\n      dragToken,\n      dispatcher,\n      isOver: currIsOver,\n      item\n    } = this.props\n    const {\n      isOver: prevIsOver\n    } = prevProps\n\n    if (!prevIsOver && currIsOver) { // enter\n      dispatcher(ENTER, {\n        source: item && item.$source,\n        target: dragToken(),\n        props: this.props,\n        component: this\n      })\n    } else if (!currIsOver && prevIsOver) { // leave\n      dispatcher(LEAVE, {\n        source: item && item.$source,\n        target: dragToken(),\n        props: this.props,\n        component: this\n      })\n    }\n  }\n\n  render () {\n    const {\n      children,\n\n      dispatcher,\n      dragToken,\n      dragCursor,\n      draggingHint,\n      dragHandlerType,\n      wrapTag: Tag,\n      wrapStyle,\n      wrapClassName,\n      draggerPreview,\n\n      connectDragSource,\n      connectDropTarget,\n      connectDragPreview,\n      isDragging,\n      isOver,\n      item,\n      itemType,\n      differenceFromInitialOffset,\n      initialClientOffset,\n      initialSourceClientOffset,\n      clientOffset,\n      sourceClientOffset,\n\n      ...otherProps\n    } = this.props\n\n    let className = wrapClassName\n    if (typeof className !== 'string' &&\n        typeof className.join === 'function') {\n      className = className.join(' ')\n    }\n\n    const style = {\n      cursor: dragHandlerType !== 'default' ? 'auto' : dragCursor,\n      ...wrapStyle\n    }\n\n    let props = {\n      className,\n      style,\n      ...otherProps\n    }\n\n    let child = children\n    if (typeof child !== 'string') {\n      child = React.Children.only(child)\n    }\n\n    if ((isDragging &&\n        typeof draggingHint === 'function' &&\n        differenceFromInitialOffset !== null)) {\n      const newProps = draggingHint(props, child)\n      if (newProps) {\n        props = newProps\n      }\n    }\n\n    if (typeof child.type !== 'string') {\n      child = (\n        <Tag {...props}>{child}</Tag>\n      )\n    } else {\n      child = React.cloneElement(child, {\n        ...child.props,\n        ...props,\n        style: {\n          ...child.props.style,\n          ...props.style\n        }\n      })\n    }\n\n    if (!draggerPreview) {\n      child = connectDragPreview(child)\n    }\n    if (dragHandlerType === 'default') {\n      child = connectDragSource(child)\n    }\n    return connectDropTarget(child)\n  }\n}\n\nclass DraggableWrapper extends React.Component {\n  static contextTypes = {\n    dispatcher: PropTypes.func,\n    draggerType: PropTypes.string,\n    dragDropManager: PropTypes.object,\n    draggerPreview: PropTypes.func\n  }\n\n  static propTypes = {\n    dragToken: PropTypes.func.isRequired,\n    draggingHint: PropTypes.func,\n    dragHandlerType: PropTypes.oneOf(['default', 'handler']),\n    dragCursor: PropTypes.oneOf(['default', 'move', 'pointer']),\n    wrapTag: PropTypes.string,\n    wrapStyle: PropTypes.object,\n    wrapClassName: PropTypes.oneOfType([\n      PropTypes.arrayOf(PropTypes.string),\n      PropTypes.string\n    ])\n  }\n\n  static defaultProps = {\n    wrapTag: 'div',\n    dragCursor: 'default',\n    dragHandlerType: 'default',\n    wrapStyle: {},\n    wrapClassName: ''\n  }\n\n  dragSource = {\n    beginDrag: this.dispatchBeginDragEvent.bind(this),\n    endDrag: this.dispatchEndDragEvent.bind(this),\n    canDrag: this.dispatchCanDragEvent.bind(this)\n  }\n\n  dropTarget = {\n    hover: this.dispatchHoverEvent.bind(this),\n    drop: this.dispatchDropEvent.bind(this),\n    canDrop: this.dispatchCanDropEvent.bind(this)\n  }\n\n  constructor (props, context) {\n    super(props, context)\n    this.cachedWrapped = undefined\n  }\n\n  componentWillUnmount () {\n    this.cachedWrapped = undefined\n  }\n\n  dispatchBeginDragEvent (props, monitor, component) {\n    const source = this.props.dragToken()\n    let result = this.context.dispatcher(\n      BEGIN_DRAG,\n      {\n        source,\n        props,\n        component\n      }\n    )\n    if (result === undefined) {\n      result = {}\n    }\n    if (result.dragToken === undefined) {\n      result.dragToken = source\n    }\n    result.$target = result.$source = result.dragToken\n    return result\n  }\n\n  dispatchEndDragEvent (props, monitor, component) {\n    const {\n      $target: target,\n      $source: source\n    } = monitor.getItem()\n    this.context.dispatcher(\n      END_DRAG,\n      {\n        target,\n        source,\n        props,\n        component\n      }\n    )\n  }\n\n  dispatchCanDragEvent (props, monitor) {\n    const source = this.props.dragToken()\n    let result = this.context.dispatcher(\n      CAN_DRAG,\n      {\n        source,\n        props\n      }\n    )\n    if (result === undefined) {\n      result = true\n    }\n    return result\n  }\n\n  dispatchHoverEvent (props, monitor, component) {\n    const current = component.props.dragToken()\n    const source = monitor.getItem().$source\n\n    if (shallowEqual(current, source) && current === source) {\n      return\n    }\n\n    monitor.getItem().$target = current\n    const handled = this.context.dispatcher(\n      HOVER,\n      {\n        target: current,\n        source,\n        props,\n        component\n      }\n    )\n\n    if (handled && (handled.constructor === current.constructor)) {\n      monitor.getItem().$target = handled\n    }\n    return handled\n  }\n\n  dispatchDropEvent (props, monitor, component) {\n    const {\n      $target: target,\n      $source: source\n    } = monitor.getItem()\n    const handled = this.context.dispatcher(\n      DROP,\n      {\n        target,\n        source,\n        props,\n        component\n      }\n    )\n    return handled\n  }\n\n  dispatchCanDropEvent (props, monitor) {\n    const {\n      $target: target,\n      $source: source\n    } = monitor.getItem()\n    let result = this.context.dispatcher(\n      CAN_DROP,\n      {\n        target,\n        source,\n        props\n      }\n    )\n    if (result === undefined) {\n      result = true\n    }\n    return result\n  }\n\n  render () {\n    const {\n      children,\n      dragToken,\n      dragCursor,\n      draggingHint,\n      wrapTag,\n      wrapStyle,\n      wrapClassName,\n      ...otherProps\n    } = this.props\n\n    const {\n      dispatcher,\n      draggerType,\n      draggerPreview\n    } = this.context\n\n    if (!this.cachedWrapped) {\n      this.cachedWrapped = DragSource(draggerType, this.dragSource, (connect, monitor) => ({\n        connectDragSource: connect.dragSource(),\n        connectDragPreview: connect.dragPreview(),\n        isDragging: monitor.isDragging(),\n        initialClientOffset: monitor.getInitialClientOffset(),\n        initialSourceClientOffset: monitor.getInitialSourceClientOffset()\n      }))(\n        DropTarget(draggerType, this.dropTarget, (connect, monitor) => ({\n          connectDropTarget: connect.dropTarget(),\n          isOver: monitor.isOver({ shallow: true }),\n          item: monitor.getItem(),\n          itemType: monitor.getItemType(),\n          differenceFromInitialOffset: monitor.getDifferenceFromInitialOffset(),\n          clientOffset: monitor.getClientOffset(),\n          sourceClientOffset: monitor.getSourceClientOffset()\n        }))(Draggable)\n      )\n    }\n    const Wrapped = this.cachedWrapped\n\n    const wrappedProps = {\n      dragCursor,\n      draggingHint,\n      wrapTag,\n      wrapStyle,\n      wrapClassName,\n      draggerPreview,\n      dragToken,\n      dispatcher\n    }\n\n    return (\n      <Wrapped {...wrappedProps} {...otherProps}>{children}</Wrapped>\n    )\n  }\n}\n\nexport default DraggableWrapper\n","export default (fn) => (type, event) => fn(type, event)\n","export default (source, target) => (options = {}) => {\n  const base = {\n    source,\n    target\n  }\n  const extra = {\n    item: options.item,\n    itemType: options.itemType,\n    isDragging: options.isDragging,\n    isOver: options.isOver,\n\n    differenceFromInitialOffset: options.differenceFromInitialOffset,\n    initialClientOffset: options.initialClientOffset,\n    initialSourceClientOffset: options.initialSourceClientOffset,\n    clientOffset: options.clientOffset,\n    sourceClientOffset: options.sourceClientOffset\n  }\n\n  return {\n    ...base,\n    ...extra\n  }\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport PropTypes from 'prop-types'\nimport eventDispatcher from './EventDispatcher'\nimport eventCreator from './EventCreator'\n\nimport {\n  DropTarget\n} from 'react-dnd'\n\nimport {\n  BEGIN_DRAG,\n  END_DRAG,\n  HOVER,\n  ENTER,\n  LEAVE,\n  DROP,\n  CAN_DRAG,\n  CAN_DROP\n} from './EventType'\n\nconst EVENT_FUNC = {\n  [BEGIN_DRAG]: 'onDragStart',\n  [END_DRAG]: 'onDragEnd',\n  [HOVER]: 'onDragging',\n  [ENTER]: 'onDragEnter',\n  [LEAVE]: 'onDragLeave',\n  [DROP]: 'onDrop',\n  [CAN_DRAG]: 'canDrag',\n  [CAN_DROP]: 'canDrop'\n}\n\nconst noop = () => {}\n\nclass Dragger extends React.Component {\n  static propTypes = {\n    onDragStart: PropTypes.func,\n    onDragEnd: PropTypes.func,\n    onDrop: PropTypes.func,\n    onDragging: PropTypes.func,\n    onDragEnter: PropTypes.func,\n    onDragLeave: PropTypes.func,\n    canDrag: PropTypes.func,\n    canDrop: PropTypes.func,\n    draggerType: PropTypes.string,\n    draggerPreview: PropTypes.func\n  }\n\n  static defaultProps = {\n    onDragStart: noop,\n    onDragEnd: noop,\n    onDrop: noop,\n    onDragging: noop,\n    onDragEnter: noop,\n    onDragLeave: noop,\n    canDrag: () => true,\n    canDrop: undefined,\n    draggerType: '__dragger__',\n    draggerPreview: undefined\n  }\n\n  static childContextTypes = {\n    dispatcher: PropTypes.func,\n    draggerType: PropTypes.string,\n    draggerPreview: PropTypes.func\n  }\n\n  static contextTypes = {\n    dragDropManager: PropTypes.object\n  }\n\n  constructor (props, context) {\n    super(props, context)\n    this.notifyHandler = this.notifyHandler.bind(this)\n    this.dispatcher = eventDispatcher(this.notifyHandler)\n  }\n\n  getChildContext () {\n    return {\n      dispatcher: this.dispatcher,\n      draggerType: this.props.draggerType,\n      draggerPreview: this.props.draggerPreview\n    }\n  }\n\n  notifyHandler (type, { target, source, props, component }) {\n    let fn = this.props[EVENT_FUNC[type]]\n    if (type === CAN_DROP && !fn) {\n      fn = this.props.canDrag\n    }\n    if (!fn) {\n      console.warn('Unknown event type', type)\n    }\n    return fn && fn(eventCreator(source, target)(props), props, component)\n  }\n\n  render () {\n    const {\n      connectDropTarget\n    } = this.props\n\n    return connectDropTarget(React.Children.only(this.props.children))\n  }\n}\n\nclass Wrapper extends React.Component {\n  static propTypes = {\n    onDragEdge: PropTypes.func,\n    edgeWidth: PropTypes.oneOfType([\n      PropTypes.number,\n      PropTypes.object\n    ]),\n    draggerType: PropTypes.string\n  }\n\n  static defaultProps = {\n    onDragEdge: noop,\n    edgeWidth: 20,\n    draggerType: '__dragger__'\n  }\n\n  dropTarget = {\n    hover: this.handleContainerHover.bind(this)\n  }\n\n  constructor (props) {\n    super(props)\n    this.edgeWidth = this.props.edgeWidth\n    if (typeof this.edgeWidth === 'number') {\n      const v = this.edgeWidth\n      this.edgeWidth = {\n        left: v,\n        top: v,\n        right: v,\n        bottom: v\n      }\n    }\n    this.cachedWrapped = undefined\n  }\n\n  componentWillUnmount () {\n    this.cachedWrapped = undefined\n  }\n\n  componentDidMount () {\n    this.refreshBoundingRect()\n  }\n\n  componentDidUpdate () {\n    this.refreshBoundingRect()\n  }\n\n  handleContainerHover (props, monitor, component) {\n    const {\n      x: clientX,\n      y: clientY\n    } = monitor.getClientOffset()\n    const {\n      left, top, right, bottom\n    } = this.containerBoundingRect\n    const {\n      left: edgeLeft,\n      top: edgeTop,\n      right: edgeRight,\n      bottom: edgeBottom\n    } = this.edgeWidth\n    const containerEdge = {\n      left: left + edgeLeft,\n      top: top + edgeTop,\n      right: right - edgeRight,\n      bottom: bottom - edgeBottom\n    }\n    const strike = {\n      left: clientX <= containerEdge.left,\n      top: clientY <= containerEdge.top,\n      right: clientX >= containerEdge.right,\n      bottom: clientY >= containerEdge.bottom\n    }\n\n    if (strike.left || strike.top || strike.right || strike.bottom) {\n      this.props.onDragEdge({\n        strike,\n        client: {\n          x: clientX,\n          y: clientY\n        },\n        edge: containerEdge,\n        itemType: monitor.getItemType(),\n        initialClientOffset: monitor.getInitialClientOffset(),\n        initialSourceClientOffset: monitor.getInitialSourceClientOffset(),\n        clientOffset: monitor.getClientOffset(),\n        sourceClientOffset: monitor.getSourceClientOffset(),\n        differenceFromInitialOffset: monitor.getDifferenceFromInitialOffset()\n      }, props, component)\n    }\n  }\n\n  refreshBoundingRect () {\n    setTimeout(() => {\n      const el = ReactDOM.findDOMNode(this)\n      this.containerBoundingRect = el.getBoundingClientRect()\n    }, 0)\n  }\n\n  render () {\n    if (!this.cachedWrapped) {\n      this.cachedWrapped = DropTarget(\n        this.props.draggerType,\n        this.dropTarget,\n        (collect, monitor) => ({\n          connectDropTarget: collect.dropTarget()\n        })\n      )(Dragger)\n    }\n    const Wrap = this.cachedWrapped\n\n    return (\n      <Wrap {...this.props}>{this.props.children}</Wrap>\n    )\n  }\n}\n\nexport default Wrapper\n","import {\n  DragDropContext\n} from 'react-dnd'\nimport HTML5Backend from 'react-dnd-html5-backend'\n\nexport default DragDropContext(HTML5Backend)\n","import React from 'react'\nimport PropTypes from 'prop-types'\n\nclass DraggerHandler extends React.Component {\n  static contextTypes = {\n    dragSourceCreator: PropTypes.func,\n    dragHandlerType: PropTypes.string,\n    dragCursor: PropTypes.string\n  }\n\n  static propTypes = {\n    wrapTag: PropTypes.string\n  }\n\n  static defaultProps = {\n    wrapTag: 'div'\n  }\n\n  render () {\n    const {\n      dragSourceCreator,\n      dragHandlerType,\n      dragCursor\n    } = this.context\n\n    const style = {\n      cursor: dragCursor,\n      ...this.props.style\n    }\n    const className = this.props.className\n\n    let children = this.props.children\n    if (dragHandlerType === 'handler') {\n      const Tag = this.props.wrapTag\n      children = dragSourceCreator(\n        <Tag className={className} style={style}>{children}</Tag>\n      )\n    }\n    return children\n  }\n}\n\nexport default DraggerHandler\n","import _Draggable from './Draggable'\nimport _Dragger from './Dragger'\nimport _DraggerContext from './DraggerContext'\nimport _DraggerHandler from './DraggerHandler'\n\nexport const Draggable = _Draggable\nexport const Dragger = _Dragger\nexport const DraggerContext = _DraggerContext\nexport const DraggerHandler = _DraggerHandler\n\nexport default {\n  Draggable,\n  Dragger,\n  DraggerContext,\n  DraggerHandler\n}\n"],"names":["Object","defineProperty","exports","value","objA","objB","keysA","keys","keysB","length","hasOwn","prototype","hasOwnProperty","i","call","valA","valB","BEGIN_DRAG","END_DRAG","DROP","HOVER","ENTER","LEAVE","CAN_DRAG","CAN_DROP","Draggable","this","props","connectDragSource","dragCursor","dragHandlerType","children","dragToken","draggerPreview","connectDragPreview","node","then","prevProps","prevState","dispatcher","currIsOver","isOver","item","prevIsOver","$source","draggingHint","Tag","wrapTag","wrapStyle","wrapClassName","connectDropTarget","isDragging","differenceFromInitialOffset","itemType","otherProps","initialClientOffset","initialSourceClientOffset","clientOffset","sourceClientOffset","className","join","style","child","React","Children","only","newProps","type","cloneElement","Component","childContextTypes","PropTypes","func","string","DraggableWrapper","context","dragSource","_this2","dispatchBeginDragEvent","bind","dispatchEndDragEvent","dispatchCanDragEvent","dropTarget","dispatchHoverEvent","dispatchDropEvent","dispatchCanDropEvent","cachedWrapped","undefined","monitor","component","source","result","$target","getItem","target","current","shallowEqual","handled","constructor","draggerType","DragSource","connect","dragPreview","getInitialClientOffset","getInitialSourceClientOffset","DropTarget","shallow","getItemType","getDifferenceFromInitialOffset","getClientOffset","getSourceClientOffset","Wrapped","wrappedProps","contextTypes","object","propTypes","isRequired","oneOf","oneOfType","arrayOf","defaultProps","fn","event","options","base","extra","EVENT_FUNC","noop","Dragger","notifyHandler","_this","eventDispatcher","canDrag","warn","eventCreator","Wrapper","handleContainerHover","edgeWidth","v","refreshBoundingRect","clientX","x","clientY","y","containerBoundingRect","left","top","right","bottom","containerEdge","strike","onDragEdge","el","ReactDOM","findDOMNode","getBoundingClientRect","collect","Wrap","number","DragDropContext","HTML5Backend","dragSourceCreator","DraggerHandler","_Draggable","_Dragger","DraggerContext","_DraggerContext","_DraggerHandler"],"mappings":"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"}